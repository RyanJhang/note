'''
题目是说，给你一串数，有正有负 要求出最大的连续子串。

其实就是标准的动态规划问题：
随着遍历这个数组，在到每一个位置的时候，弄一个局部最大L值，代表以当前位置为结尾的最大子串，比如说我遍历到第i个，那么以第i个为结尾的最大子串就是我们要求的L。

比如这个题目：
-2 , 1, −3,4,−1,2,1,−5,4
位置0，L=x=-2，没得选
位置1，要以x=1为结尾的最大的，那肯定不要带上之前的-2,只要1就好L=x=1
位置2，因为本身x=-3，加上上一个位置L 是正数1，所以L=L+x=-3+1=-2。
下面以此类推得到：

对应的L应该是：
-2, 1, -2,4,3,5,6,-1,3

而全局最大值G就是我们最终想要的结果，
肯定这个全局最大值出自局部最大值。
（因为全局最大的那个子串的结尾肯定在数组里，言外之意就是不管怎么样这个G都肯定出自L）
最后找到最大的那个L就是我们想要的G了。
————————————————
版权声明：本文为CSDN博主「zl87758539」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zl87758539/article/details/51676108

'''


class Solution:
    def maxSubArray(self, nums) -> int:
        l = g = nums[0]
        for n in nums[1:]:
            l = max(n, l + n)
            g = max(l, g)
        return g


Solution().maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4])
# Solution().maxSubArray([5,4,-1,7,8])
